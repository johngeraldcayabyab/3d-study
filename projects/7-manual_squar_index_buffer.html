<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        html, body {
            margin: 0; /* remove the default margin          */
            height: 100%; /* make the html,body fill the page   */
        }

        canvas {
            display: block; /* make the canvas act like a block   */
            width: 100%; /* make the canvas fill its container */
            height: 100%;
        }
    </style>
</head>
<body>
<canvas></canvas>
<script>
    async function main() {
        const adapter = await navigator.gpu?.requestAdapter();
        const device = await adapter?.requestDevice();
        if (!device) {
            fail('need a browser that supports WebGPU');
            return;
        }

        // Get a WebGPU context from the canvas and configure it
        const canvas = document.querySelector('canvas');
        const context = canvas.getContext('webgpu');
        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
            device,
            format: presentationFormat,
        });

        const module = device.createShaderModule({
            label: 'our hardcoded rgb square shaders',
            code: `


      @vertex fn vs(
        @builtin(vertex_index) vertexIndex : u32
      ) -> @builtin(position) vec4f {
        let pos = array(
          vec2f(-0.5, 0.5),
          vec2f(0.5, 0.5),
         vec2f(-0.5, -0.5),

         vec2f(0.5, 0.5),
         vec2f(0.5, -0.5),
         vec2f(-0.5, -0.5),
        );

        let testPos = array(
           vec2f(-.5, .5),
           vec2f(.5,.5),
           vec2f(.5, -.5),
           vec2f(-.5, -.5),
        );

        return vec4f(pos[vertexIndex], 0.0, 1.0);
      }

      @fragment fn fs() -> @location(0) vec4f {
        return vec4(1, 0,0 ,1);
      }
    `,
        });

        const pipeline = device.createRenderPipeline({
            label: 'hardcoded rgb square pipeline',
            layout: 'auto',
            vertex: {
                module,
                entryPoint: 'vs',
            },
            fragment: {
                module,
                entryPoint: 'fs',
                targets: [{format: presentationFormat}],
            },
        });

        const renderPassDescriptor = {
            label: 'our basic canvas renderPass',
            colorAttachments: [
                {
                    // view: <- to be filled out when we render
                    clearValue: [0.3, 0.3, 0.3, 1],
                    loadOp: 'clear',
                    storeOp: 'store',
                },
            ],
        };


        const squareVertices = new Float32Array([
            -0.5, 0.5,
            0.5, 0.5,
            -0.5, -0.5,

            0.5, 0.5,
            0.5, -0.5,
            -0.5, -0.5,
        ]);

        const squareVertexBuffer = device.createBuffer({
            label: 'vertex buffer vertices',
            size: squareVertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });

        device.queue.writeBuffer(squareVertexBuffer, 0, squareVertices);

        function render() {
            // Get the current texture from the canvas context and
            // set it as the texture to render to.
            renderPassDescriptor.colorAttachments[0].view =
                context.getCurrentTexture().createView();

            const encoder = device.createCommandEncoder({
                label: 'render square encoder',
            });
            const pass = encoder.beginRenderPass(renderPassDescriptor);
            pass.setPipeline(pipeline);
            pass.draw(6);  // call our vertex shader 3 times
            pass.end();

            const commandBuffer = encoder.finish();
            device.queue.submit([commandBuffer]);
        }

        const observer = new ResizeObserver(entries => {
            for (const entry of entries) {
                const canvas = entry.target;
                const width = entry.contentBoxSize[0].inlineSize;
                const height = entry.contentBoxSize[0].blockSize;
                canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
                canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
                // re-render
                render();
            }
        });
        observer.observe(canvas);
    }

    function fail(msg) {
        // eslint-disable-next-line no-alert
        alert(msg);
    }

    main();

</script>
</body>
</html>
